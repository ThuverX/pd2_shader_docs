"use strict";(self.webpackChunkpd_2_shader_docs=self.webpackChunkpd_2_shader_docs||[]).push([[7703],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>c});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),d=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(o.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(a),h=r,c=u["".concat(o,".").concat(h)]||u[h]||m[h]||l;return a?n.createElement(c,i(i({ref:t},p),{},{components:a})):n.createElement(c,i({ref:t},p))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=h;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var d=2;d<l;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},2048:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var n=a(7462),r=(a(7294),a(3905));const l={sidebar_position:1,title:"Shader File Format",category:"Shader"},i=void 0,s={unversionedId:"shaderformat",id:"shaderformat",title:"Shader File Format",description:"This file describes the .shaders file format used by Payday 2. It's a custom format used to store the shaders used by the game.",source:"@site/docs/shaderformat.mdx",sourceDirName:".",slug:"/shaderformat",permalink:"/pd2_shader_docs/docs/shaderformat",draft:!1,editUrl:"https://github.com/thuverx/pd2_shader_docs/tree/main/docs/shaderformat.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Shader File Format",category:"Shader"},sidebar:"docsSidebar",previous:{title:"Introduction",permalink:"/pd2_shader_docs/docs/intro"},next:{title:"Generated",permalink:"/pd2_shader_docs/docs/Generated/"}},o={},d=[{value:"Headers",id:"headers",level:2},{value:"Objects",id:"objects",level:2},{value:"Object types",id:"object-types",level:3},{value:"Shader Library",id:"shader-library",level:3},{value:"Shader",id:"shader",level:3},{value:"Shader pass",id:"shader-pass",level:3},{value:"Render States",id:"render-states",level:2},{value:"Sampler States",id:"sampler-states",level:2}],p={toc:d},u="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This file describes the ",(0,r.kt)("inlineCode",{parentName:"p"},".shaders")," file format used by Payday 2. It's a custom format used to store the shaders used by the game."),(0,r.kt)("p",null,"(All values are stored in little endian.)"),(0,r.kt)("h2",{id:"headers"},"Headers"),(0,r.kt)("p",null,"The file is structured as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The start of the file is the padding and the number of ",(0,r.kt)("a",{parentName:"li",href:"#objects"},"Objects"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Either ",(0,r.kt)("inlineCode",{parentName:"li"},"count")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"-1")," (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"If the previous value was ",(0,r.kt)("inlineCode",{parentName:"li"},"-1"),", then this is ",(0,r.kt)("inlineCode",{parentName:"li"},"padding")," (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"And if the previous value was ",(0,r.kt)("inlineCode",{parentName:"li"},"padding")," then this is the ",(0,r.kt)("inlineCode",{parentName:"li"},"count")," instead (4 bytes)"))),(0,r.kt)("li",{parentName:"ul"},"A list of ",(0,r.kt)("a",{parentName:"li",href:"#objects"},"Objects"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Each object has a ",(0,r.kt)("inlineCode",{parentName:"li"},"type")," according to ",(0,r.kt)("a",{parentName:"li",href:"#object-types"},"Types")," (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"A reference id so this object can be referenced to by other objects (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"size")," of the object (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"The data of the object (",(0,r.kt)("inlineCode",{parentName:"li"},"size")," bytes)")))),(0,r.kt)("h2",{id:"objects"},"Objects"),(0,r.kt)("h3",{id:"object-types"},"Object types"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Shader")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"0x7F3552D1")),(0,r.kt)("td",{parentName:"tr",align:null},"Contains a list of techniques with shader passes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Shader Pass")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"0x214b1aaf")),(0,r.kt)("td",{parentName:"tr",align:null},"Contains render and sampler state along with a vertex and pixel shader")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Shader Library")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"0x12812C1A")),(0,r.kt)("td",{parentName:"tr",align:null},"Contains a list of shader templates")))),(0,r.kt)("h3",{id:"shader-library"},"Shader Library"),(0,r.kt)("p",null,"The Shader Library Object contains a list of ",(0,r.kt)("a",{parentName:"p",href:"#shader"},"shader templates"),"."),(0,r.kt)("p",null,"It is structured as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"count"),", the number of shader templates (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"A list of references to shader templates:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"/docs/lookup8"},"lookup8 hash")," of the shader templates name (8 bytes)"),(0,r.kt)("li",{parentName:"ul"},"The reference id to the shader template object (4 bytes)")))),(0,r.kt)("h3",{id:"shader"},"Shader"),(0,r.kt)("p",null,"The Shader Object contains a list of techniques each containing a list of passes."),(0,r.kt)("p",null,"It is structured as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"count"),", the number of techniques (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"A list of techniques:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"/docs/lookup8"},"lookup8 hash")," of the technique name (8 bytes)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"count"),", the number of passes (4 bytes)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"reference id to the shader pass object (4 bytes)")))))),(0,r.kt)("h3",{id:"shader-pass"},"Shader pass"),(0,r.kt)("p",null,"The Shader Pass Object contains the bulk of the relevant data for the shaders. It contains the render and sampler state along with the vertex and pixel shader."),(0,r.kt)("p",null,"It is structured as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"render_state_count"),", the number of render states (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"A list of render states according to ",(0,r.kt)("a",{parentName:"li",href:"#render-states"},"Render States")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sampler_state_count"),", the number of sampler states (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"A list of sampler states according to ",(0,r.kt)("a",{parentName:"li",href:"#sampler-states"},"Sampler States")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vertex_shader_size"),", the size of the vertex shader data (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vertex_shader_data"),", the vertex shader data (",(0,r.kt)("inlineCode",{parentName:"li"},"vertex_shader_size")," bytes)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pixel_shader_size"),", the size of the pixel shader data (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pixel_shader_data"),", the pixel shader data (",(0,r.kt)("inlineCode",{parentName:"li"},"pixel_shader_size")," bytes)")),(0,r.kt)("h2",{id:"render-states"},"Render States"),(0,r.kt)("p",null,"A Render State contains information how this shader should render."),(0,r.kt)("p",null,"It is structured as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"id"),", the ",(0,r.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/windows/win32/direct3d9/d3drenderstatetype"},"D3DRENDERSTATETYPE")," as a 32 bit integer (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"b"),", whether is value is a ",(0,r.kt)("inlineCode",{parentName:"li"},"int")," or a ",(0,r.kt)("inlineCode",{parentName:"li"},"long")," (1 byte)"),(0,r.kt)("li",{parentName:"ul"},"if ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," is equal to ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value4"),", the value of the render state (4 bytes)"))),(0,r.kt)("li",{parentName:"ul"},"else if ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," is not equal to ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value8"),", the value of the render state (8 bytes)")))),(0,r.kt)("h2",{id:"sampler-states"},"Sampler States"),(0,r.kt)("p",null,"A Sampler State contains information about how a sampler should sample a texture."),(0,r.kt)("p",null,"It is structured as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"id"),", the id the sampler (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"state_count"),", the number of state for this sampler (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},"A list of states:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"id"),", the ",(0,r.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/windows/win32/direct3d9/d3dsamplerstatetype"},"D3DSAMPLERSTATETYPE")," as a 32 bit integer (4 bytes)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"b"),", whether is value is a ",(0,r.kt)("inlineCode",{parentName:"li"},"int")," or a ",(0,r.kt)("inlineCode",{parentName:"li"},"long")," (1 byte)"),(0,r.kt)("li",{parentName:"ul"},"if ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," is equal to ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value4"),", the value of the render state (4 bytes)"))),(0,r.kt)("li",{parentName:"ul"},"else if ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," is not equal to ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value8"),", the value of the render state (8 bytes)")))))),(0,r.kt)("h1",{id:"imhex-pattern"},"ImHex Pattern"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'import std.sys;\nimport std.string;\n\nenum ObjectType: u32 {\n    Shader = 0x7F3552D1,\n    ShaderPass = 0x214b1aaf,\n    ShaderLibrary = 0x12812C1A\n};\n\nstruct Header {\n    ObjectType type;\n    u32 ref_id;\n    u32 size;\n};\n\nstruct Technique {\n    u64 hash;\n    u32 pass_count;\n    u32 passes[pass_count];\n};\n\nstruct ShaderRef {\n    u64 hash;\n    u32 ref_id;\n};\n\nstruct StateVar {\n    u32 id;\n    u8 b;\n    if(b == 0) {\n        u32 value4;\n    } else {\n        u64 value8;\n    }\n};\n\nstruct SamplerState {\n    u32 id;\n    u32 state_count;\n    StateVar states[state_count];\n};\n\nstruct ObjectShader {\n    u32 technique_count;\n    Technique techniques[technique_count];\n};\n\nstruct ObjectShaderLibrary {\n    u32 template_count;\n    ShaderRef templates[template_count];\n};\n\nstruct ObjectShaderPass {\n    u32 render_state_count;\n    StateVar render_states[render_state_count];\n    u32 sampler_state_count;\n    SamplerState sampler_states[sampler_state_count];\n    u32 vertex_shader_size;\n    char vertex_shader_bytes[vertex_shader_size];\n    u32 pixel_shader_size;\n    char pixel_shader_bytes[pixel_shader_size];\n};\n\nstruct Object {\n    Header header;\n    u32 start = $;\n\n    if(header.type == ObjectType::Shader) {\n        ObjectShader object_shader [[inline]];\n    } else if(header.type == ObjectType::ShaderLibrary) {\n        ObjectShaderLibrary object_shader_library [[inline]];\n    }\n    else {\n        ObjectShaderPass object_shader_pass [[inline]];\n    }\n    \n    u32 remaining = header.size - ($ - start);\n    \n    std::assert(remaining == 0,\n        "Object has invalid size, " + std::string::to_string(remaining) + " remaining");\n};\n\nstruct FileHeader {\n    s32 value [[hidden]];\n    if(value == -1) {\n        padding[4];\n        u32 object_count;\n    } else {\n        u32 object_count = value;\n    }\n    \n    Object objects[object_count];\n};\n\nFileHeader header @ 0;\n')))}m.isMDXComponent=!0}}]);